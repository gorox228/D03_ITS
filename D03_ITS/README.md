# Понимание и обработка исключений

## Аннотация

Данный проект позволит Тебе улучшить твой навык работы с исключениями (ошибками), умение их читать, а так же обрабатывать и вызывать.

## Chapter I

### Чтение и исправление исключений


> Одно из самых главных умений любого программиста - это умение работать с ошибками, которые тебе постоянно всплывают.
> Метод работы: написал код, выполнил, получил ошибку, исправил ошибку, выполнил, получил новую ошибку и т.д., никто не отменял.
> Это главный принцип работы любого программиста. Умение гуглить и читать/исправлять ошибки - вот те два главных кита, на которых держится черепаха эффективности разработчика.
> 
> Ниже приведен пример кода с ошибкой (слева в файле указана нумерация строк). В Python ошибки называются **исключениями**.
> ```python
> 1 # Пример кода с ошибкой
> 2 
> 3 a = 0
> 4
> 5 print(1 / 0)
> 6
> ```
> При его выполнении, ты получишь следующую ошибку
> ```
> Traceback (most recent call last):
> File "/home/previous_admin/project_3_handling_exceptions/src/example_error.py", line 5, in <module>
>    print(1 / 0)
>         ~~^~~
> ZeroDivisionError: division by zero
> ```
> Давай разберемся с ней. В первую очередь тебе нужно смотреть на последнюю строчку.
> 
> **ZeroDivisionError: division by zero**
> 
> **ZeroDivisionError** - это имя ошибки, считай, что именно его нужно гуглить в первую очередь, когда ты не знаешь, что это за ошибка.
> Однако, перед тем как гуглить - прочитай текст после двоеточия: "**division by zero**". Если у тебя плохо с английским, не стесняйся вставлять эту строчку в гугл переводчик.
> В ней написано - деление на ноль. И действительно, математика запрещает делить на ноль (вообще более продвинутые математики могут это делать, но не будем здесь об этом).
> 
> Далее, как только ты понял **ЧТО** за **исключение** выпало, нужно понять **ГДЕ** это случилось.
> 
> **File "/home/previous_admin/project_3_handling_exceptions/src/example_error.py", line 5, in <module>**
> 
> Эта строчка показывает:
> - в каком файле встретилась ошибка, после слова **File** указан **абсолютный путь** до этого файла - "**/home/previous_admin/project_3_handling_exceptions/src/example_error.py**";
> - на какой строке встретилась ошибка, номер строки с ошибкой указан после слова **line**, в данном примере номер линии с ошибкой - 5.
> 
> Ну и следующая строчка в ошибке **print(1 / 0)** часто показывает в каком конкретно куске кода выпало **исключение**.
> 
> Запомни, когда твоя программа падает с ошибкой, ты должен сделать следующее:
> - идти и читать ошибку;
> - понять **ЧТО** это за ошибка, если не знаешь - гугли;
> - понять **ГДЕ** эта ошибка встречается;
> - поправить конкретный кусок кода, где встретилась ошибка.
> 
> При этом ты НЕ должен:
> - не читая ошибку, бежать и смотреть свой основной код;
> - не читая ошибку, пытаться что-то поправить;
> - не читая ошибку, перезапускать программу миллион раз, надеясь, что случится чудо;
> - не читая ошибку, падать на клавиатуру, кататься по ней лицом и молится, чтобы рандомные нажатия спасут ситуацию.
> 
> Я тебе подготовил ряд заданий, которые помогут научиться тебе читать и работать с **исключениями**. 
> И не путайся, слово **исключение** в Python встречается чаще, чем ошибка.

### Задание 1

> В файле [*task_1.py*](src/task_1.py) представлено твое первое задание, в этом и последующем заданиях тебе будет даваться нерабочий код, который выплевывает **исключения**.
> Данный код делает какие-то арифметические операции и выводит результат на экран.
> Твоя задача поправить код и сделать его рабочим (то есть он должен выполняться без ошибок).
> Изучи все операции, запиши их на листочке, вычисли и проверь результат.
>
> Кстати, обрати внимание, что в этом задании я тебе привел пример **комментариев** в коде. Комментарии разработчики оставляют для себя
> и других разработчиков. Поверь, через пару дней, ты уже забудешь, что твой код делает. Комментарии очень важны! Старайся не пренебрегать ими.
> 

### Задание 2

> В файле [*task_2.py*](src/task_2.py) твое второе задание. Обрати внимание, что здесь представлены разные способы задавания строк (через разные виды кавычек).
> Код просто объявляет пару, другую строк, делает операции с ними и выводит на экран две из них. Твоя задача все та же - поправить ошибки, а также ИЗУЧИТЬ операции на строках (`+` и `*`), посмотреть что они делают и какой результат дают.

### Задание 3

> В файле [*task_3.py*](src/task_3.py) твое третье задание. В нем задается строка и осуществляются какие-то операции с ней, применяются какие-то методы и даже чуток срезов!
> Ну и в конце результат этих операций выводится на экран. 
> 
> И как-то здесь уже больше подчеркиваний от PyCharm, не считаешь? На самом деле PyCharm
> подчеркивает не только ошибки, но и плохой **стиль кода** (про него я тебе расскажу потом). Подчеркивания кода от **IDE** - это полезно, но не самое главное.

### Задание 4

> В файле [*task_4.py*](src/task_4.py) твое четвертое задание. Хм, кажется, ты уже можешь почувствовать закономерность в первом предложении.
> Ну да ладно, в этом задании с клавиатуры нужно ввести число. Но ты же не всегда должен следовать правилам, не так ли?
> Даешь хаос! Попробуй ввести строку вместо числа.
> 
> Ух, ну ты и бунтарь, конечно. А теперь сбалансируй хаос и следуй тому, что тебя просят в программе, т.е. введи число.

## Chapter III

### Обработка исключений

> Надеюсь, ты понял, как нужно действовать в случае возникновения **исключений**.
> 
> Однако, бывают моменты, когда **исключения** будут выпадать в тех случаях, когда не все зависит от тебя. Например, твоя программа берет число 10
> и делит его на число, которое пользователь вводит с клавиатуры. Никто не запретит пользователю ввести ноль (если, конечно, не стоять с палкой у него за спиной).
> И БАЦ, ошибка деления на ноль.
> 
> Да, в этом случае можно проверять с помощью **if**, является ли введенное пользователем числом и не нулем.
> Но бывают случаи, когда исключения с помощью **if** не поймать. Допустим, какой-то сайт под капотом идет в базу данных и пытается найти там какую-то информацию.
> В этот момент отваливается сеть. Через какое-то время код выдаст исключение, связанное с **timeout**, то есть условно 10 секунд код пытался связаться с базой данных,
> не смог и выдает ошибку - время на связь с базой данных кончилось! Если эту ошибку не обработать, то сайт упадет. Вместо этого хочется просто выдавать клиенту сообщение - "Какие-то проблемы, попробуйте через пару минут".
> 
> Так вот эта обработка называется **обработка исключений**. В Python она реализована через блок **try-except**.
> Следующие задания будут направлены на понимание обработки исключений с помощью этого блока. При этом блоков **except** может быть несколько.

### Задание 5

> В файле [*task_5.py*](src/task_5.py) представлено твое пятое задание.\
> Во-первых, не удивляйся, что какие-то странные ошибки в коде. Я все еще пытаюсь показать тебе разные виды исключений в питоне.\
> Во-вторых, данная программа просит ввести число от -10 до 10 (надеюсь на твою честность при вводе). А далее делает **что-то**.
> Вот это я конечно интриган. Разберись сам, что происходит в коде. Как только он у тебя заработает, запусти его столько раз, 
> сколько потребуется, чтобы появилось исключение (не переживай, на какой-то раз оно точно появится).
> 
> Как только ты поймаешь исключение - обработай его с помощью блока **try-except**. Я хочу, чтобы вместо исключения на экран выводилось сообщение
> "Корень из отрицательного числа брать нельзя!".

### Задание 6

> В файле... А я думаю, что ты сам догадаешься в каком файле находится твое шестое задание. Ну ладно, вот твой файл - [*task_6.py*](src/task_6.py).\
> В данном задании демонстрируется работа **индексов** в строках. По доброй традиции код содержит ошибку, которая не позволит тебе его полностью выполнить.\
> Как только ты поправишь эту ошибку, может сложиться впечатление, что все ок. Однако, в программировании есть просто правило - если твой клиент МОЖЕТ когда-нибудь сделать что-то не так,
> он обязательно это СДЕЛАЕТ. Так, например, он может ввести вместо индекса - 1, 2, 3, индекс 100! Или даже 1000!
> Попробуй сделать это - получишь исключение. Вот его нужно будет обработать.
> 
> А теперь я признаюсь, что скрыл от тебя кое-что. Блок **try-except** может быть расширен. Ключевые слова **try** и **except** действительно обязательны в этом блоке.
> Однако, есть также необязательные ключевые слова **else** и **finally**. Прочитай, что они делают.
> 
> Вернемся к тому, КАК обработать эту ошибку:
> - ЕСЛИ код выполнился без исключений, то пусть выводится строка - 'И да, такой индекс действительно был!'. Но запиши ее внутри **else**;
> - ЕСЛИ код внутри **try** выплюнул исключение, то пусть выдает на экран строку - 'Такого индекса нет в этой строке!';
> - в конце кода ВСЕГДА пусть выводит строку - 'Конец!', используй для этого дополнительное ключевое слово этого блока.
> 
> Обращу внимание еще раз, всю обработку нужно осуществить внутри расширенного блока **try-except-else-finally**.
> 
> P.S. Несмотря на то, что знать про **else** и **finally** необходимо в блоке **try-except**, в реальной жизни они применяются не очень часто.
> Поэтому не удивляйся вопросам в своей голове - а нафига они вообще нужны?! Редко - нужны, но в большинстве случаев у программистов тот же вопрос.

## Chapter IV

### Ручное возбуждение исключений

> Может прозвучать довольно странно, но иногда тебе нужно будет самому вызывать исключения, чтобы программа падала с ошибкой. 
> 
> Допустим, при делении на ноль ты хочешь, что программа падала с ошибкой, однако перед этим выводила на экран логин того, кто ввел этот ноль (если у вас есть авторизация).
> Страна ведь должна знать своих геров в лицо?! Тогда ты можешь в блоке **except** вывести на экран логин, а после этого уже возбудить ту же самую ошибку **ZeroDivisionError**.
> 
> Ошибка вызывается с помощью ключевого слова **raise**, далее идет имя ошибки. При этом в скобках ты можешь передать текст, который будет отображаться при появлении этого исключения.

### Задание 7

> Итак, твое последнее испытание на ошибки ждет в файле [*task_7.py*](src/task_7.py). Программа в этом файле показывает тебе, как работают срезы в строках.
> Как они записываются, ты можешь посмотреть в коде, а что выводят посмотреть на экране вывода. На самом деле срезы в некоторых моментах работают не интуитивно.
> Попробуй, например, ввести в качестве первого индекса 1000, а второго 10. Программа выполнилась! Ничего не упало... Просто в качестве среза вернулась пустая строка.
> 
> Давай попробуем добавить чуть больше логики в срезы. Пусть программа инициирует исключение `IndexError("Какая-то фигня у вас с индексами!")` при следующих условиях:
> - ЕСЛИ первый индекс среза БОЛЬШЕ ИЛИ РАВЕН второму индексу среза;
>
> ИЛИ
> 
> - ЕСЛИ первый индекс среза БОЛЬШЕ длины строки;
> 
> ИЛИ
> 
> - ЕСЛИ второй индекс среза БОЛЬШЕ длины строки;
>
> P.S. Учти случаи, что пользователь может не вводить индекс и передавать вместо первого и/или второго индексов пустую строку в переменные.

## Chapter V

### Заключение

Звонит будильник. Ты поднимаешь глаза от компьютера, смотришь на время и видишь 7 часов вечера. Кажется пора закругляться, друзья ждут!
Ты ощущаешь приятное чувство. Выходной, а ты не только отдохнешь, но и уже сделал полезное дело.
По результатам сегодняшнего дня ты решаешь сделать для себя следующие выводы:
- частые ошибки (или, как они называются в питоне) **исключения** - это нормальная часть работы;
- для эффективной работы нужно уметь читать **исключения**;
- если не хочется, чтобы программа прерывалась на каком-то **исключении** можно **обработать** его с помощью блока **try-except**;
- в блоке **try-except** есть необязательные части **else** и **finally**, которые используются не часто, но лучше не забывать про их существование;
- если тебе захочется, то ты сам можешь вызвать исключение с помощью ключевого слова **raise**.